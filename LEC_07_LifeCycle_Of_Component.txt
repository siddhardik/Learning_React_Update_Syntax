React's lifecycle includes the phases in the following order -
Mounting phase for component creation, Updating phase for state or prop changes, Unmounting phase for removing components from the DOM, and Error Handling phase for the rendering of lifecycle errors.

Handling user events such as onClick or onChange is not an action that should be performed using a side effect.

Setting the state or causing side effects in the above three functions leads to errors, infinite loops, and undefined behavior. Whereas setting the state or causing side effects in componentDidMount() leads to a single rerender of the component.

After setting the state in the componentDidMount() method, the component rerenders, and the getDerivedStateFromProps() method is called first, and then, the render() method is called implicitly.

As getDerivedStateFromProps() is a static method, it does not have access to the instance of the component class. The this keyword is undefined in the getDerivedStateFromProps() method so the setState() method cannot be used.

We can use this.setState() under componentDidMount(), getDerivedStateFromProps() based on condition , we can not use this keyword here it is a static method 


render function looping => if we use this.state inside render function it will call render function implicitly Which will cause render function call looping .

A. Constructor has been invoked => First
ComponentA.js:17 A. getDerivedStateFromProps has been invoked => Second
ComponentA.js:26 A. This render has been invoked => Third 
ComponentB.js:12  B. Constructor has been invoked => First
ComponentB.js:16  B. getDerivedStateFromProps has been invoked => Second
ComponentB.js:25 B. This render has been invoked => Third 
ComponentB.js:21 B. componentDidMount has been invoked => Last
ComponentA.js:22 A. componentDidMount has been invoked => Last